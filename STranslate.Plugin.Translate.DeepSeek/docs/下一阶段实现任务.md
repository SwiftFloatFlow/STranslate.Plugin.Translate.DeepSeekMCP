# DeepSeekMCP 插件 - 下一阶段实现任务

## 自查结果总结

根据检查报告分析，插件已实现大部分核心功能，但仍有若干待优化项。以下将问题分为**已解决**、**待实现**两类，并提供详细的任务清单。

---

## 一、已解决问题（无需再实现）

### 1. 工具调用控制机制 ✅
- **报告提及**：缺少总工具调用次数限制和同一工具连续调用限制
- **实现状态**：**已完成**
  - `StrategyTotalToolCallsLimits`：策略级总工具调用上限
  - `StrategyConsecutiveToolLimits`：策略级同一工具连续调用上限
  - 默认值为 5 次（可在策略编辑对话框中调整）
  - 最近修复：强制退出工具循环时缺少虚拟工具响应的问题

### 2. 设置保存防抖 ✅
- **报告提及**：频繁写磁盘可能导致性能下降
- **实现状态**：**已完成**
  - 已实现 `DelayedSaveSettings` 防抖机制
  - 延迟 500ms 后保存，期间有新变更则重置计时器

### 3. 策略级设置 UI 同步 ✅
- **报告提及**：命令修改设置后需通知 ViewModel 更新
- **实现状态**：**已完成**
  - `StrategyEvents` 弱引用事件系统
  - 自动垃圾回收，无需手动取消订阅

### 4. 三阶段内容构建器 ✅
- **报告提及**：工具链和工具结果显示的实现方式不明
- **实现状态**：**已完成**
  - `ThreeStageContentBuilder` 类负责内容构建
  - 支持 4 种工具结果显示模式（禁用/粗略/混合/详细）
  - 内联显示工具名和结果

### 5. 取消令牌传递 ✅
- **报告提及**：循环中未考虑取消令牌
- **实现状态**：**已完成**
  - `cancellationToken` 已传递到所有 API 调用和工具调用

---

## 二、待实现任务（按优先级排序）

### 🔴 高优先级（架构/稳定性）

#### 任务 1：MCP 客户端连接池实现
**问题描述**：
- 每次翻译都重新创建 McpClient 并建立连接
- 造成不必要的网络开销和延迟
- 并发请求多时可能导致服务器连接数激增

**实现方案**：
```csharp
public class McpClientPool : IDisposable
{
    private readonly ConcurrentDictionary<string, PooledMcpClient> _clients = new();
    private readonly TimeSpan _idleTimeout = TimeSpan.FromMinutes(5);
    private readonly Timer _cleanupTimer;
    
    public async Task<McpClient> GetClientAsync(string serverUrl, string apiKey)
    {
        var client = _clients.GetOrAdd(serverUrl, url => 
            new PooledMcpClient(url, apiKey, _idleTimeout));
        
        await client.EnsureConnectedAsync();
        client.LastUsedTime = DateTime.UtcNow;
        return client;
    }
    
    // 定期清理空闲连接
    private void CleanupIdleClients()
    {
        var idleClients = _clients.Where(c => c.Value.IsIdle).ToList();
        foreach (var client in idleClients)
        {
            if (_clients.TryRemove(client.Key, out var pooledClient))
            {
                pooledClient.Dispose();
            }
        }
    }
}
```

**验收标准**：
- [ ] 实现连接池类，按服务器 URL 复用客户端
- [ ] 空闲超时自动断开（默认5分钟）
- [ ] 需要时自动重连
- [ ] 线程安全地分配和回收
- [ ] 插件退出时正确释放所有连接

**相关文件**：
- `McpClient.cs` - 需要支持连接状态检测和重置
- `Main.cs` - 改为从连接池获取客户端

---

#### 任务 2：并发安全性验证与增强
**问题描述**：
- `Main._mcpClients` 是类级别列表，多请求可能共享
- `McpClient` 内部的请求 ID 计数、连接状态可能被竞态修改

**实现方案**：
1. **方案 A（推荐）**：确保每个翻译请求使用独立客户端实例
   - 从连接池租用，使用期间独占
   - 使用 `AsyncLocal` 或请求上下文隔离

2. **方案 B**：使 `McpClient` 内部线程安全
   - 使用 `lock` 或 `SemaphoreSlim` 保护关键操作
   - 原子操作更新请求 ID

**验收标准**：
- [ ] 验证当前 `McpClient` 的线程安全性
- [ ] 实现请求级客户端隔离或内部线程安全
- [ ] 压力测试：模拟 10+ 并发翻译请求
- [ ] 确保无竞态条件和数据错乱

**相关文件**：
- `McpClient.cs` - 添加线程安全机制
- `Main.cs` - 确保正确获取和释放客户端

---

#### 任务 3：资源释放与 IDisposable 完善
**问题描述**：
- `McpClient` 内部使用 `HttpClient`，需要正确释放
- 可能还有其他资源（计时器、事件处理器）需要释放

**实现方案**：
```csharp
public class McpClient : IDisposable
{
    private readonly HttpClient _httpClient;
    private bool _disposed;
    private CancellationTokenSource? _connectionCts;
    
    public void Dispose()
    {
        if (_disposed) return;
        
        _disposed = true;
        _connectionCts?.Cancel();
        _connectionCts?.Dispose();
        _httpClient?.Dispose();
        
        // 清理其他资源...
    }
    
    // 确保方法中检查 _disposed
}
```

**验收标准**：
- [ ] `McpClient` 正确实现 `IDisposable`
- [ ] 释放 HttpClient、取消令牌源等
- [ ] 防止重复释放（`_disposed` 标志）
- [ ] 释放后方法调用抛出 `ObjectDisposedException`
- [ ] 插件退出时调用 `Dispose`

**相关文件**：
- `McpClient.cs` - 实现 IDisposable
- `Main.cs` - 确保 Dispose 被调用

---

### 🟡 中优先级（错误处理/用户体验）

#### 任务 4：错误处理细化与重试机制
**问题描述**：
- 当前错误处理粒度较粗，丢失具体错误信息
- 部分工具调用失败后直接标记为失败
- 缺少超时控制和自动重试

**实现方案**：
```csharp
// 定义错误类型
public enum McpErrorType
{
    ConnectionError,    // 连接错误（可重试）
    AuthenticationError,// 认证错误（不重试）
    ToolNotFound,       // 工具不存在（不重试）
    ParameterError,     // 参数错误（不重试）
    Timeout,            // 超时（可重试）
    Unknown             // 未知错误
}

// 重试策略
public class RetryPolicy
{
    public int MaxRetries { get; set; } = 3;
    public TimeSpan BaseDelay { get; set; } = TimeSpan.FromSeconds(1);
    
    public async Task<T> ExecuteAsync<T>(Func<Task<T>> action, McpErrorType errorType)
    {
        if (!IsRetryable(errorType)) return await action();
        
        for (int i = 0; i < MaxRetries; i++)
        {
            try
            {
                return await action();
            }
            catch (Exception ex) when (i < MaxRetries - 1)
            {
                await Task.Delay(BaseDelay * Math.Pow(2, i));
            }
        }
        throw new McpRetryExhaustedException();
    }
}
```

**验收标准**：
- [ ] 定义自定义异常类型和错误分类
- [ ] 为每个工具调用添加超时控制（10-30秒可配置）
- [ ] 对临时性错误（网络抖动）实现指数退避重试
- [ ] 区分可重试和不可重试错误
- [ ] 记录完整的异常堆栈

**相关文件**：
- `McpClient.cs` - 细化错误处理
- 新增 `McpException.cs` - 自定义异常

---

#### 任务 5：命令系统 MCP 关闭提示
**问题描述**：
- 用户可能忘记已关闭 MCP，输入 `/切换` 等命令被当作普通文本
- 静默忽略造成混淆

**实现方案**：
```csharp
private Task<CommandResult> ExecuteCommandAsync(string text)
{
    if (!Settings.EnableMcp)
    {
        return Task.FromResult(new CommandResult
        {
            IsCommand = true,
            Success = false,
            Message = "❎ MCP 服务已禁用，命令不可用\n" +
                     "请先在设置中启用 MCP 服务，或使用 /mcp 命令开启"
        });
    }
    // ... 原有逻辑
}
```

**验收标准**：
- [ ] MCP 关闭时，输入 `/` 命令返回明确提示
- [ ] 提示用户如何启用 MCP
- [ ] 而不是静默当作普通文本发送

**相关文件**：
- `Main.cs` - 修改 `ExecuteCommandAsync`

---

#### 任务 6：工具列表缓存优化
**问题描述**：
- 每次翻译都重新获取工具列表
- 工具列表在短时间内通常不会变化

**实现方案**：
```csharp
public class McpClient
{
    private List<ToolInfo>? _cachedTools;
    private DateTime _toolsCacheTime;
    private readonly TimeSpan _toolsCacheTtl = TimeSpan.FromMinutes(5);
    
    public async Task<List<ToolInfo>> ListToolsAsync()
    {
        if (_cachedTools != null && 
            DateTime.UtcNow - _toolsCacheTime < _toolsCacheTtl)
        {
            return _cachedTools;
        }
        
        _cachedTools = await FetchToolsFromServerAsync();
        _toolsCacheTime = DateTime.UtcNow;
        return _cachedTools;
    }
    
    // 服务器通知变更时刷新
    public void InvalidateToolsCache()
    {
        _cachedTools = null;
    }
}
```

**验收标准**：
- [ ] 工具列表缓存 5 分钟
- [ ] 提供手动刷新按钮或机制
- [ ] 服务器通知变更时自动刷新
- [ ] 缓存失效时正确重新获取

**相关文件**：
- `McpClient.cs` - 添加工具列表缓存
- `SettingsView.xaml` - 添加手动刷新按钮

---

### 🟢 低优先级（性能/体验优化）

#### 任务 7：并发请求限制
**问题描述**：
- 无限制地同时发起大量 API 请求
- 可能耗尽本地资源或触发 API 限流

**实现方案**：
```csharp
public class TranslationLimiter
{
    private readonly SemaphoreSlim _semaphore = new(5, 5); // 最大5个并发
    
    public async Task<T> ExecuteWithLimitAsync<T>(Func<Task<T>> action)
    {
        await _semaphore.WaitAsync();
        try
        {
            return await action();
        }
        finally
        {
            _semaphore.Release();
        }
    }
}
```

**验收标准**：
- [ ] 使用 `SemaphoreSlim` 限制并发翻译请求
- [ ] 默认限制 5 个并发（可配置）
- [ ] 等待时支持取消令牌

**相关文件**：
- `Main.cs` - 添加并发限制

---

#### 任务 8：策略编辑对话框增强
**问题描述**：
- 滑块缺少数值显示
- 缺少预览功能
- 恢复默认按钮无确认提示

**实现方案**：
- 滑块旁添加数值输入框，双向绑定
- 添加预览区域，展示插入工具描述后的提示词
- 恢复默认按钮添加确认对话框

**验收标准**：
- [ ] 滑块数值实时显示，支持直接输入
- [ ] 预览功能：展示 `$description_rough` 和 `$description_detailed` 替换效果
- [ ] 恢复默认按钮点击后弹出确认对话框
- [ ] 对话框关闭前提示保存（如有未保存更改）

**相关文件**：
- `StrategyPromptDialog.xaml` - UI 增强
- `StrategyPromptDialogViewModel.cs` - 逻辑实现

---

#### 任务 9：日志级别动态调整
**问题描述**：
- 修改日志级别后可能需要重启才能生效

**实现方案**：
- 使用 `IOptionsMonitor` 模式或事件通知
- 日志级别变更时重新配置日志记录器

**验收标准**：
- [ ] 修改日志级别后立即生效
- [ ] 无需重启插件

**相关文件**：
- `Main.cs` - 动态调整日志级别

---

#### 任务 10：配置版本兼容性
**问题描述**：
- 插件升级添加新设置项时，旧配置文件可能导致行为异常
- 缺少配置迁移逻辑

**实现方案**：
```csharp
public class Settings : ObservableObject
{
    public int ConfigVersion { get; set; } = 1;
    
    public void Migrate()
    {
        if (ConfigVersion < 2)
        {
            // 迁移到版本 2：添加新的策略级设置默认值
            foreach (var strategy in Enum.GetValues<McpToolStrategy>())
            {
                if (!StrategyToolChainDisplay.ContainsKey(strategy))
                    StrategyToolChainDisplay[strategy] = false;
                    
                if (!StrategyToolResultDisplayModes.ContainsKey(strategy))
                    StrategyToolResultDisplayModes[strategy] = ToolResultDisplayMode.Disabled;
            }
            ConfigVersion = 2;
        }
    }
}
```

**验收标准**：
- [ ] 添加 `ConfigVersion` 属性
- [ ] 实现 `Migrate` 方法
- [ ] 加载配置后自动执行迁移
- [ ] 每次添加新设置项时更新版本号和迁移逻辑

**相关文件**：
- `Settings.cs` - 添加版本和迁移逻辑
- `SettingsViewModel.cs` - 加载时调用迁移

---

## 三、任务执行建议

### 第一阶段（1-2周）：架构稳定性
1. 任务 3：资源释放与 IDisposable（基础）
2. 任务 1：MCP 客户端连接池（架构优化）
3. 任务 2：并发安全性验证（稳定性）

### 第二阶段（2-3周）：错误处理与用户体验
4. 任务 4：错误处理细化与重试机制
5. 任务 5：命令系统 MCP 关闭提示
6. 任务 6：工具列表缓存优化

### 第三阶段（3-4周）：性能与体验优化
7. 任务 7：并发请求限制
8. 任务 8：策略编辑对话框增强
9. 任务 9：日志级别动态调整
10. 任务 10：配置版本兼容性

---

## 四、需要更新的文档

### 已解决问题文档更新
- [ ] `docs/modules/mcp-client.md` - 更新连接池设计（已实现）
- [ ] `docs/modules/main-logic.md` - 更新错误处理章节（已实现）
- [ ] `docs/README.md` - 更新 v3.0+ 已完成功能

### 待实现任务文档
- [ ] 为每个任务创建详细设计文档（在 `docs/tasks/` 目录下）

---

## 五、风险与注意事项

1. **连接池实现**：
   - 需确保线程安全
   - 正确处理并发获取和释放
   - 避免内存泄漏

2. **并发安全性**：
   - 修改前需充分测试现有代码
   - 考虑使用 `lock` 的性能开销

3. **资源释放**：
   - 确保 `Dispose` 模式正确实现
   - 使用 `try-finally` 或 `using` 确保释放

4. **向后兼容**：
   - 连接池实现需兼容现有 API
   - 避免破坏现有功能

---

**最后更新**：2026年2月16日  
**文档版本**：v1.0
